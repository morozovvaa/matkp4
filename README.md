# Практическая работа 4 - Разработка механик и эффектов в 2D-игре с использованием Pygame  
## Цель работы: Освоить реализацию простых механик, эффектов и взаимодействий в рамках 2D-игр, используя pygame. Каждая механика разрабатывается независимо от остальных на основе одной и той же базовой заготовки игры, что позволяет сосредоточиться на конкретных аспектах каждой реализации.  

### Задание 1. Базовая заготовка игры
#### Описание исходного кода

Исходный код представляет собой базовую структуру 2D-игры и содержит следующие элементы:

*   **Инициализация Pygame:**
    *   Инициализация библиотеки Pygame (`pygame.init()`).
    *   Настройка параметров окна игры (`pygame.display.set_mode()`, `pygame.display.set_caption()`) и частоты кадров (`pygame.time.Clock()`).
    *   Определение основных цветов (белый, черный, синий, красный).
*   **Инициализация игровых объектов:**
    *   Размеры игрока, объектов и стен (`PLAYER_SIZE`, `OBJECT_SIZE`, `WALL_THICKNESS`).
    *   Начальные координаты игрока (`player_x`, `player_y`) и его скорость (`player_dx`, `player_dy`).
    *   Создание списка `objects` с прямоугольными объектами (препятствиями).
*   **Основной игровой цикл:**
    *   Обработка событий (`pygame.event.get()`):
        *   Закрытие окна (`pygame.QUIT`).
        *   Нажатие клавиш управления (`pygame.KEYDOWN`):  задание направления движения персонажа.
        *   Отпускание клавиш управления (`pygame.KEYUP`): остановка движения персонажа.
    *   Обновление позиции игрока на основе его скорости: `player_x += player_dx`, `player_y += player_dy`.
    *   Ограничение перемещения игрока в пределах границ окна: `player_x = max(...)`, `player_y = max(...)`.
    *   Отрисовка элементов на экране:
        *   Очистка экрана белым цветом (`screen.fill(WHITE)`).
        *   Отрисовка стен (`pygame.draw.rect()`).
        *   Отрисовка персонажа (`pygame.draw.rect()`, `pygame.draw.line()`).
        *   Отрисовка неподвижных объектов (`pygame.draw.rect()`).
    *   Обновление экрана и контроль частоты кадров: `pygame.display.flip()`, `clock.tick(FPS)`.

#### Модификации и добавление проверки столкновений

Внесены следующие изменения для реализации проверки столкновений:

*   **Создание прямоугольника персонажа:**
    ```python
    player_rect = pygame.Rect(player_x, player_y, PLAYER_SIZE, PLAYER_SIZE)
    ```
    Создается объект `pygame.Rect` для представления области, занимаемой персонажем, что необходимо для проверки столкновений.

*   **Проверка столкновений с объектами:**

    ```python
    for obj in objects:
        if player_rect.colliderect(obj):
           # Обнаружено столкновение. Меняем направление скорости игрока на противоположное
            if player_dx > 0:  # Движение вправо
                player_x = obj.left - PLAYER_SIZE -1
            elif player_dx < 0: # Движение влево
               player_x = obj.right + 1
            elif player_dy > 0:
              player_y = obj.top - PLAYER_SIZE - 1 # движение вниз
            elif player_dy < 0:
               player_y = obj.bottom + 1 #движение вверх
    ```

    *   Создаётся цикл для перебора всех объектов в списке `objects`.
    *   Используется метод `player_rect.colliderect(obj)` для проверки пересечения прямоугольников персонажа и текущего объекта.
    *   При обнаружении столкновения:
         *  Определяется направление движения игрока
        *  Позиция игрока меняется на границу объекта со стороны его направления.
   

### Задание 2. Ближний бой
#### Описание внесенных изменений

В модифицированный код были добавлены и изменены следующие элементы:

*   **Визуализация зоны атаки:**
    *   Добавлена переменная `show_attack_zone` типа bool для управления отображением зоны атаки.
    *   При нажатии клавиши `SPACE` эта переменная устанавливается в `True`.
    *   В цикле отрисовки добавлена проверка, если `show_attack_zone`  равна `True`, отрисовывается желтый прямоугольник, показывающий область атаки.
    *    После отрисовки флаг `show_attack_zone` сбрасывается, чтобы зона отображалась только один кадр во время нажатия клавиши.
*    **Обновление позиции:**
    *  Убрано изменение скорости при столкновении, вместо этого проверяется пересечение со всеми объектами и меняется только позиция игрока.
*   **Интегрированная проверка столкновений**:
    *  Проверка на столкновение с врагами производится теперь отдельной функцией `check_collision_with_objects`
*   **Автоматическое появление врагов**:
    *    Добавлено автоматическое появление новых врагов каждые 3 секунды
    *   Появление нового врага исключает пересечение с другими объектами и игроком.
*   **Константы и переменные:**
    *   Добавлена константа `YELLOW` для задания цвета зоны атаки.
    *   Добавлена переменная `SPAWN_INTERVAL` для установки интервала появления нового врага.
     *   Добавлена переменная `time_since_last_spawn` для хранения времени прошедшего с последнего появления нового врага.

#### Детали реализации

*   **Визуализация зоны атаки:**
    *   Создается прямоугольная область (`attack_zone`) вокруг персонажа.
    *   Область рисуется только если установлен флаг `show_attack_zone`.
    *   Область рисуется желтым цветом.
    *  Использование флага позволяет отобразить область атаки только один кадр.
*  **Столкновения:** Функция проверки столкновений сохранена и используется для остановки игрока перед обьектами.
*   **Автоматическое появление врагов:**  На основе значения `time_since_last_spawn`  и значения `SPAWN_INTERVAL` вызывается функция `spawn_enemy`
*  **Унифицирован подход к обработке столкновений:** Игрок больше не отталкивается при столкновении с обьектами, а прижимается к границе обьекта.


### Задание 3. Гравитация и прыжки
#### Описание изменений
##### Добавление переменных и констант

*   `JUMP_FORCE`: Константа, определяющая начальную вертикальную скорость персонажа при прыжке. Отрицательное значение используется для движения вверх.
*   `GRAVITY`: Константа, определяющая силу гравитации, которая влияет на вертикальную скорость персонажа.
*   `is_jumping`: Флаг, определяющий, находится ли персонаж в прыжке.
*   `moving_left`, `moving_right`: Флаги для отслеживания движения влево и вправо.

##### Обработка прыжка (событие `KEYDOWN`)

*   При нажатии клавиши `SPACE` и если флаг `is_jumping` не установлен:
    *   Вертикальная скорость персонажа устанавливается в значение `JUMP_FORCE`.
    *   Флаг `is_jumping` устанавливается в `True`.

##### Обработка движения влево-вправо (события `KEYDOWN` и `KEYUP`)

*   При нажатии `pygame.K_LEFT` или `pygame.K_RIGHT`:
    *   Устанавливается соответствующий флаг `moving_left` или `moving_right` в `True`.
    *   Горизонтальная скорость персонажа задается соответствующим значением.
*   При отпускании `pygame.K_LEFT` или `pygame.K_RIGHT`:
    *   Устанавливается соответствующий флаг `moving_left` или `moving_right` в `False`.
    *   Горизонтальная скорость сбрасывается в `0` только если не удерживается другая клавиша.

##### Обновление вертикальной скорости (гравитация)

*   В каждом игровом цикле к вертикальной скорости персонажа добавляется значение `GRAVITY`.

##### Проверка столкновения с платформами и приземление

*  Создается обьект типа `pygame.Rect`, для дальнейшей проверки столкновений.
*   В цикле проверяется пересечение персонажа с платформами.
*   Если игрок пересекается с платформой и двигается вниз:
    *   Персонаж "ставится" на верхнюю границу платформы.
    *   Вертикальная скорость сбрасывается на `0`.
     *  Флаг `is_jumping` сбрасывается и переменная `on_ground` устанавливается в `True`.
        *   Использование оператора `break` ускоряет работу цикла, при нахождении одной из платформ.

##### Ограничение падения до нижней границы экрана

* Проверяется, не вышла ли нижняя граница персонажа за нижнюю границу окна.
*   Если вышла, то позиция игрока приравнивается к нижней границе, вертикальная скорость обнуляется, флаг `is_jumping` сбрасывается и устанавливается  `on_ground` в `True`.

##### Обновление позиции персонажа

*   Обновление позиции персонажа на основе его скоростей с учетом силы тяжести.

##### Результат

В результате этих изменений:

*   Персонаж теперь подвержен воздействию гравитации и падает при отсутствии опоры.
*   Персонаж может прыгать, нажимая клавишу `SPACE`.
*   Персонаж может приземляться на платформы.
*   Использование флагов `moving_left` и `moving_right` предотвращает баг застревания персонажа.

### Задание 4. Ловушки
#### Реализация

#### 1. Исчезающие платформы

#### 1.1. Дизайн
*   **Визуальное представление:** Исчезающие платформы реализованы в виде прямоугольников пурпурного цвета.
*   **Механика:** При контакте с персонажем платформа начинает постепенно исчезать, становясь все более прозрачной. После определенного времени (2 секунды) платформа полностью исчезает. Персонаж может стоять на платформе пока она не исчезла
*   **Повторное появление:** После исчезновения платформа не появляется вновь.

#### 1.2. Код
*   **Хранение данных:** Хрупкие платформы хранятся в списке `fragile_platforms` в виде `pygame.Rect` объектов. Для каждой платформы создан таймер `fragile_timers` и `surface` для отрисовки.
*   **Таймер:**  Для каждой платформы ведется отсчет времени от начала ее касания.
*   **Удаление:**  Платформа удаляется из списков, когда ее таймер достигает предела.
*   **Отрисовка:** Прозрачность платформы динамически изменяется в зависимости от времени существования.
*   **Столкновение:** У платформы проверяется столкновение с персонажем, если оно произошло и персонаж падает или стоит на платформе, то платформа начинает исчезать.

#### 1.3. Проблемы и решения
*   **Проблема:** Изначально персонаж проваливался сквозь платформу при касании.
*   **Решение:** Добавил проверку `player_dy >= 0`, чтобы персонаж мог стоять на платформе только если он падает сверху или стоит на ней.

#### 2. Шипы

#### 2.1. Дизайн
*   **Визуальное представление:** Шипы реализованы в виде прямоугольников оранжевого цвета, которые располагаются на платформах.
*   **Механика:** При контакте с персонажем шипы наносят урон здоровью.
*   **Таймер между уроном:** При получении урона персонаж мигает и не может получать урон некоторое время (одна секунда), это сделано чтобы персонаж не умирал моментально.

#### 2.2. Код
*   **Хранение данных:** Шипы хранятся в списке `traps` в виде `pygame.Rect` объектов.
*   **Урон:**  При столкновении с шипами здоровье персонажа уменьшается на 10 единиц, и включается таймер `player_blink_timer`.
*   **Таймер:** Таймер `player_blink_timer` отвечает за время мигания персонажа и делает его неуязвимым к урону на это время.
*   **Отрисовка:** Шипы отрисовываются на экране.

#### 2.3. Проблемы и решения
*   **Проблема:** Изначально персонаж получал урон несколько раз при одном столкновении с ловушкой.
*   **Решение:** Добавлен таймер `player_blink_timer` и проверка на его состояние, чтобы урон наносился только раз в определенный промежуток времени.

## Результаты

*   **Исчезающие платформы:** Реализованы хрупкие платформы, которые исчезают при контакте с персонажем, предоставляя игроку сложность в передвижении по уровню и необходимость продумывать свои действия.
*   **Шипы:** Добавлены шипы, которые наносят урон игроку, что добавляет опасности в игровой процесс и заставляет игрока избегать контакта с ними.




### Задание 5. Эффект портала
## Реализация

### 1. Дизайн
*   **Визуальное представление:** Порталы представлены в виде прямоугольников бирюзового (teal) цвета.
*   **Механика:** При контакте с одним из порталов персонаж мгновенно перемещается в центр другого портала.
*   **Предотвращение зацикливания:** После телепортации персонаж получает короткий период "неуязвимости" (кулдаун) к телепортации, чтобы избежать бесконечного перемещения между порталами.

### 2. Код

*   **Хранение данных:** Порталы хранятся в виде объектов `pygame.Rect` в переменных `portal1` и `portal2`.
*   **Генерация порталов:**  Функция `create_portals` генерирует координаты порталов случайным образом, но на достаточном расстоянии друг от друга (минимум 200 пикселей по каждой оси), чтобы избежать перекрытия.
*   **Таймер:**  Переменная `portal_timer` управляет "неуязвимостью" после телепортации. При телепортации значение `portal_timer` устанавливается на `PORTAL_COOLDOWN`, а при каждом кадре оно уменьшается, пока не достигнет нуля.
*   **Столкновение:** Проверяется столкновение персонажа с `portal1` или `portal2`. Если столкновение произошло и `portal_timer` равен 0, то персонаж перемещается в соответствующий портал.
*   **Отрисовка:** Порталы отрисовываются на экране.

### 3. Проблемы и решения

*   **Проблема:**  Изначально персонаж застревал в бесконечном цикле телепортаций между порталами.
*   **Решение:** Добавлен "кулдаун" после телепортации с помощью таймера `portal_timer`, который на короткое время отключает возможность телепортироваться, предотвращая зацикливание.

## Результаты

*   **Порталы:** В игру добавлены порталы, которые перемещают персонажа из одной точки в другую.
*   **Избежание зацикливания:** Телепортация реализована с таймером, предотвращающим зацикливание и обеспечивающим плавное перемещение.



### Задание 6. Сбор предметов


#### 1. Монеты

#### 1.1. Дизайн
*   **Визуальное представление:** Монеты представлены в виде прямоугольников золотого цвета.
*   **Механика:** При контакте с персонажем монета исчезает и увеличивает счет игрока на 10 очков.
*   **Размещение:** Монеты размещаются случайным образом на игровом поле. При размещении избегаются платформы, ловушки, хрупкие платформы и порталы.
*   **Обновление:** При смерти игрока монеты обновляются, предоставляя новую возможность для сбора.

#### 1.2. Код
*   **Хранение данных:** Монеты хранятся в списке `coins` в виде объектов `pygame.Rect`.
*   **Генерация:**  Функция `create_coins` создает монеты в случайных местах, избегая перекрытия с другими игровыми элементами.
*   **Удаление:**  Монета удаляется из списка при столкновении с персонажем.
*   **Отрисовка:** Монеты отрисовываются на экране как прямоугольники.

#### 2. Система счета

#### 2.1. Дизайн
*   **Визуальное представление:** Счет выводится на экран в левом верхнем углу.
*   **Механика:** Счет увеличивается при сборе монет (на 10 очков за монету) и убийстве врагов (на 50 очков за каждого убитого врага).
*   **Сброс:** Счет сбрасывается на 0 при смерти персонажа.

#### 2.2. Код
*   **Переменная:**  Счет хранится в переменной `score`.
*   **Увеличение счета:** 
    *   При сборе монет, `score` увеличивается на 10.
    *   При атаке и удалении врагов, `score` увеличивается на 50 за каждого убитого врага.
*   **Сброс счета:**  При смерти персонажа значение переменной `score` обнуляется.
*   **Отрисовка:** Счет отрисовывается на экране с помощью `pygame.font.Font` и `screen.blit`.

#### Результаты

*   **Сбор предметов:** Реализован сбор монет, что добавило цель исследования игрового мира.
*   **Система счета:** Реализована система счета, которая увеличивается при сборе монет и убийстве врагов, давая игроку стимул для прогресса.
*   **Обнуление счета:** Счет обнуляется при смерти, что поддерживает баланс в игре и стимулирует игрока к осторожности.
*   **Обновление монет:** Монеты появляются заново при смерти персонажа, предоставляя новую возможность для сбора.

